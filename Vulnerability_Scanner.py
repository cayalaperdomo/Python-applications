import requests
from bs4 import BeautifulSoup
import tkinter as tk
from tkinter import messagebox, scrolledtext
import json

# Función para formatear URLs
def format_url(url):
    if not url.startswith(('http://', 'https://')):
        url = 'https://' + url
    return url

# Escaneo de archivos sensibles
def check_sensitive_files(url):
    sensitive_paths = ["/robots.txt", "/.git/", "/.env", "/config/", "/.htaccess"]
    results = {}
    for path in sensitive_paths:
        try:
            response = requests.get(url + path, timeout=10)
            if response.status_code == 200:
                results[path] = "❌ Exposed"
            else:
                results[path] = "✅ Not Found"
        except Exception:
            results[path] = "⚠️ Error Checking"
    return results

# Verificar encabezados de seguridad con explicaciones
def check_security_headers(headers):
    results = {}
    explanations = []

    # Content-Security-Policy (CSP)
    if "Content-Security-Policy" not in headers:
        results["Content-Security-Policy"] = "❌ Missing"
        explanations.append({
            "header": "Content-Security-Policy",
            "issue": "Faltante",
            "description": "Protege contra inyecciones de scripts al restringir los recursos que el navegador puede cargar.",
            "recommendation": "Implementa un encabezado CSP adecuado para prevenir ataques XSS."
        })
    else:
        results["Content-Security-Policy"] = f"✅ {headers['Content-Security-Policy']}"

    # Strict-Transport-Security
    if "Strict-Transport-Security" not in headers:
        results["Strict-Transport-Security"] = "❌ Missing"
        explanations.append({
            "header": "Strict-Transport-Security",
            "issue": "Faltante",
            "description": "Asegura que todas las conexiones sean mediante HTTPS.",
            "recommendation": "Configura este encabezado con 'max-age=31536000' para proteger contra ataques de downgrade."
        })
    else:
        results["Strict-Transport-Security"] = f"✅ {headers['Strict-Transport-Security']}"

    # X-Content-Type-Options
    if "X-Content-Type-Options" not in headers:
        results["X-Content-Type-Options"] = "❌ Missing"
        explanations.append({
            "header": "X-Content-Type-Options",
            "issue": "Faltante",
            "description": "Evita que el navegador interprete incorrectamente los tipos de contenido (MIME).",
            "recommendation": "Añade este encabezado con 'nosniff' para proteger los tipos MIME."
        })
    else:
        results["X-Content-Type-Options"] = f"✅ {headers['X-Content-Type-Options']}"

    # X-XSS-Protection
    if "X-XSS-Protection" not in headers:
        results["X-XSS-Protection"] = "❌ Missing"
        explanations.append({
            "header": "X-XSS-Protection",
            "issue": "Faltante",
            "description": "Ayuda a los navegadores a mitigar ataques de XSS.",
            "recommendation": "Configura este encabezado con '1; mode=block' para habilitar la protección."
        })
    else:
        results["X-XSS-Protection"] = f"✅ {headers['X-XSS-Protection']}"

    return results, explanations

# Escaneo de formularios inseguros
def check_forms(soup):
    form_results = {}
    forms = soup.find_all("form")
    for form in forms:
        action = form.get("action", "Unknown")
        method = form.get("method", "GET").upper()
        if method == "GET":
            form_results[action] = "❌ Insecure Method (GET)"
        else:
            form_results[action] = "✅ Secure Method (POST)"
    return form_results

# Verificar configuración CORS
def check_cors(headers):
    if "Access-Control-Allow-Origin" in headers:
        if headers["Access-Control-Allow-Origin"] == "*":
            return "❌ Insecure CORS Policy (Wildcard)"
        else:
            return f"✅ CORS Policy: {headers['Access-Control-Allow-Origin']}"
    else:
        return "✅ No CORS Policy Detected"

# Escaneo de subdominios simulados
def check_subdomains(url):
    subdomains = [f"api.{url}", f"test.{url}", f"staging.{url}"]
    results = {}
    for sub in subdomains:
        try:
            response = requests.get("https://" + sub, timeout=10)
            if response.status_code == 200:
                results[sub] = "❌ Subdomain Accessible"
            else:
                results[sub] = "✅ Not Accessible"
        except Exception:
            results[sub] = "⚠️ Error Checking"
    return results

# Métodos HTTP permitidos
def check_http_methods(url):
    methods = ["GET", "POST", "PUT", "DELETE", "TRACE"]
    results = {}
    for method in methods:
        try:
            response = requests.request(method, url, timeout=10)
            if response.status_code in [200, 405]:
                results[method] = "✅ Allowed"
            else:
                results[method] = "❌ Forbidden"
        except Exception:
            results[method] = "⚠️ Error Checking"
    return results

# Analizar encabezado X-Powered-By para tecnologías
def detect_technologies(headers):
    if "X-Powered-By" in headers:
        return f"❌ Exposed Technology: {headers['X-Powered-By']}"
    return "✅ No Technology Information Exposed"

# Función principal de análisis
def scan_url(url):
    try:
        url = format_url(url)
        response = requests.get(url, timeout=10, allow_redirects=True)
        soup = BeautifulSoup(response.text, "html.parser")
        header_results, header_explanations = check_security_headers(response.headers)

        report = {
            "url": url,
            "sensitive_files": check_sensitive_files(url),
            "security_headers": header_results,
            "forms": check_forms(soup),
            "cors": check_cors(response.headers),
            "subdomains": check_subdomains(url.replace("https://", "").replace("http://", "")),
            "http_methods": check_http_methods(url),
            "technologies": detect_technologies(response.headers),
            "explanations": header_explanations
        }

        return report

    except requests.exceptions.RequestException as e:
        return {"error": str(e)}

# Guardar reporte en JSON
def save_report(report, filename="detailed_scan_report.json"):
    with open(filename, 'w') as file:
        json.dump(report, file, indent=4)

# Mostrar resultados en pantalla
def display_results(report):
    result_text.delete(1.0, tk.END)

    if "error" in report:
        result_text.insert(tk.END, f"Error: {report['error']}\n")
    else:
        result_text.insert(tk.END, f"Results for: {report['url']}\n")
        result_text.insert(tk.END, "-" * 50 + "\n")
        for section, results in report.items():
            if isinstance(results, dict):
                result_text.insert(tk.END, f"{section}:\n")
                for key, value in results.items():
                    result_text.insert(tk.END, f"  {key}: {value}\n")
        result_text.insert(tk.END, "\nDetailed explanations:\n")
        for explanation in report["explanations"]:
            result_text.insert(tk.END, f"{explanation['header']}: {explanation['description']}\n")
            result_text.insert(tk.END, f"Recommendation: {explanation['recommendation']}\n\n")

        save_report(report)
        result_text.insert(tk.END, "Detailed report saved to 'detailed_scan_report.json'\n")

# Crear interfaz gráfica
window = tk.Tk()
window.title("Advanced Vulnerability Scanner")
window.geometry("900x800")

# Campo para ingresar URL
url_label = tk.Label(window, text="Enter URL to scan:")
url_label.pack(pady=5)

url_entry = tk.Entry(window, width=60)
url_entry.pack(pady=5)

# Botones
scan_button = tk.Button(window, text="Start Scan", command=lambda: display_results(scan_url(url_entry.get())))
scan_button.pack(pady=10)

exit_button = tk.Button(window, text="Exit", command=window.destroy)
exit_button.pack(pady=5)

# Área de texto para los resultados
result_text = scrolledtext.ScrolledText(window, width=100, height=40)
result_text.pack(pady=10)

# Iniciar la aplicación
window.mainloop()
